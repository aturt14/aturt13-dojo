id: aturt13-dojo
name: aturt13 Dojo
type: public
award:
  emoji: üê¢
image: pwncollege/challenge-legacy:latest
modules:
  - id: blindfmt
    name: Blind Format String Exploits
    description: |
      Exploiting format string vulnerabilities may seem challenging at first, but it essentially allows an attacker to gain both arbitrary read and write primitives. Once those primitives are obtained, code execution is just one step away. However, what happens when the output of the format string is not visible?
    challenges:
      - id: level-0
        name: "level0"
        description: Refresh your knowledge of writing arbitrary values with format strings.
      - id: level-1-0
        name: "level1.0"
        description: Copy a secret to a known address.
      - id: level-1-1
        name: "level1.1"
        description: Copy a secret to an unknown address.
      - id: level-2
        name: "level2"
        description: |
          What you see is all there is. What if you can't see anything? Use a blind format string exploit to perform ROP to gain code execution.
          Hint: The answer might be `42`.
      - id: level-3
        name: "level3"
        description: No more bruteforce! Can you read using arbitrary write?
  - id: blindheap
    name: Blind Dynamic Allocator Exploitation
    description: |
      The field of dynamic allocator exploitation appears to be as dynamic as the allocators themselves. Whenever a new PoC showcasing a particularly effective abuse of the dynamic allocator is patched, fresh methods of heap exploitation emerge. After the introduction of safelinking, it was widely believed that leakless heap exploitation had been permanently eliminated from the hacking landscape. It was stated that a successful exploit requires at least two different vulnerabilities. Yet is this really the case?
    challenges:
      - id: level-1
        name: "level1"
        description: Practice for the next level with failing eyesight.
      - id: level-2
        name: "level2"
        description: Now you're completely blind! But perhaps you'll find a way to restore your sight...
  - id: fuzzing
    name: Fuzzing 
    image: aturt13/pwncollege-dojo-aflplusplus:latest
    description: |
      Identifying vulnerabilities in large codebases through manual means is both inefficient and time-consuming. As code length increases, complex interdependent elements hinder manual analysis. Race conditions and intricate heap corruption vulnerabilities can be oftentimes triggered only by a very complex sequence of actions. As human minds struggle to manually assess vast amounts of data, we can leverage computers and algorithms to do the hard work for us.

      You might want to add the following to your shell init file:
      ```
      export AFL_I_DONT_CARE_ABOUT_MISSING_CRASHES=1
      export AFL_SKIP_CPUFREQ=1
      ```
    challenges:
      - id: level-1-0
        name: "level1.0"
        description: |
          Leverage afl-fuzz and afl-clang-fast to find an input that causes the program to crash. You have the source code available.
      - id: level-1-1
        name: "level1.1"
        description: |
          Exploit the binary.
      - id: level-2-0
        name: "level2.0"
        description: |
          Use `afl-fuzz` with dictionaries to cause the program to crash.
      - id: level-2-1
        name: "level2.1"
        description: |
          Exploit the binary.
      - id: level-3-0
        name: "level3.0"
        description: |
          Let's see how you cope with a fuzzing-unfriendly program.
      - id: level-3-1
        name: "level3.1"
        description: |
          Exploit the binary.
      - id: level-4-0
        name: "level4.0"
        description: |
          What if you don't have source code?
      - id: level-4-1
        name: "level4.1"
        description: |
          Exploit the binary.
